Suche nach Index: 227

Gefundene Funktion aus CSV:
eval7(
    char_u	**arg,
    typval_T	*rettv,
    evalarg_T	*evalarg,
    int		want_string)	// after "." operator
{
    int		evaluate = evalarg != NULL
				      && (evalarg->eval_flags & EVAL_EVALUATE);
    int		len;
    char_u	*s;
    char_u	*name_start = NULL;
    char_u	*start_leader, *end_leader;
    int		ret = OK;
    char_u	*alias;

    /*
     * Initialise variable so that clear_tv() can't mistake this for a
     * string and free a string that isn't there.
     */
    rettv->v_type = VAR_UNKNOWN;

    /*
     * Skip '!', '-' and '+' characters.  They are handled later.
     */
    start_leader = *arg;
    if (eval_leader(arg, in_vim9script()) == FAIL)
	return FAIL;
    end_leader = *arg;

    if (**arg == '.' && (!isdigit(*(*arg + 1))
#ifdef FEAT_FLOAT
	    || in_old_script(2)
#endif
	    ))
    {
	semsg(_(e_invalid_expression_str), *arg);
	++*arg;
	return FAIL;
    }

    switch (**arg)
    {
    /*
     * Number constant.
     */
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    case '.':	ret = eval_number(arg, rettv, evaluate, want_string);

		// Apply prefixed "-" and "+" now.  Matters especially when
		// "->" follows.
		if (ret == OK && evaluate && end_leader > start_leader
						  && rettv->v_type != VAR_BLOB)
		    ret = eval7_leader(rettv, TRUE, start_leader, &end_leader);
		break;

    /*
     * String constant: "string".
     */
    case '"':	ret = eval_string(arg, rettv, evaluate);
		break;

    /*
     * Literal string constant: 'str''ing'.
     */
    case '\'':	ret = eval_lit_string(arg, rettv, evaluate);
		break;

    /*
     * List: [expr, expr]
     */
    case '[':	ret = eval_list(arg, rettv, evalarg, TRUE);
		break;

    /*
     * Dictionary: #{key: val, key: val}
     */
    case '#':	if (in_vim9script())
		{
		    ret = vim9_bad_comment(*arg) ? FAIL : NOTDONE;
		}
		else if ((*arg)[1] == '{')
		{
		    ++*arg;
		    ret = eval_dict(arg, rettv, evalarg, TRUE);
		}
		else
		    ret = NOTDONE;
		break;

    /*
     * Lambda: {arg, arg -> expr}
     * Dictionary: {'key': val, 'key': val}
     */
    case '{':	if (in_vim9script())
		    ret = NOTDONE;
		else
		    ret = get_lambda_tv(arg, rettv, in_vim9script(), evalarg);
		if (ret == NOTDONE)
		    ret = eval_dict(arg, rettv, evalarg, FALSE);
		break;

    /*
     * Option value: &name
     */
    case '&':	ret = eval_option(arg, rettv, evaluate);
		break;

    /*
     * Environment variable: $VAR.
     */
    case '$':	ret = eval_env_var(arg, rettv, evaluate);
		break;

    /*
     * Register contents: @r.
     */
    case '@':	++*arg;
		if (evaluate)
		{
		    if (in_vim9script() && IS_WHITE_OR_NUL(**arg))
			semsg(_(e_syntax_error_at_str), *arg);
		    else if (in_vim9script() && !valid_yank_reg(**arg, FALSE))
			emsg_invreg(**arg);
		    else
		    {
			rettv->v_type = VAR_STRING;
			rettv->vval.v_string = get_reg_contents(**arg,
								GREG_EXPR_SRC);
		    }
		}
		if (**arg != NUL)
		    ++*arg;
		break;

    /*
     * nested expression: (expression).
     * or lambda: (arg) => expr
     */
    case '(':	ret = NOTDONE;
		if (in_vim9script())
		{
		    ret = get_lambda_tv(arg, rettv, TRUE, evalarg);
		    if (ret == OK && evaluate)
		    {
			ufunc_T *ufunc = rettv->vval.v_partial->pt_func;

			// Compile it here to get the return type.  The return
			// type is optional, when it's missing use t_unknown.
			// This is recognized in compile_return().
			if (ufunc->uf_ret_type->tt_type == VAR_VOID)
			    ufunc->uf_ret_type = &t_unknown;
			if (compile_def_function(ufunc,
				     FALSE, COMPILE_TYPE(ufunc), NULL) == FAIL)
			{
			    clear_tv(rettv);
			    ret = FAIL;
			}
		    }
		}
		if (ret == NOTDONE)
		{
		    *arg = skipwhite_and_linebreak(*arg + 1, evalarg);
		    ret = eval1(arg, rettv, evalarg);	// recursive!

		    *arg = skipwhite_and_linebreak(*arg, evalarg);
		    if (**arg == ')')
			++*arg;
		    else if (ret == OK)
		    {
			emsg(_(e_missing_closing_paren));
			clear_tv(rettv);
			ret = FAIL;
		    }
		}
		break;

    default:	ret = NOTDONE;
		break;
    }

    if (ret == NOTDONE)
    {
	/*
	 * Must be a variable or function name.
	 * Can also be a curly-braces kind of name: {expr}.
	 */
	s = *arg;
	len = get_name_len(arg, &alias, evaluate, TRUE);
	if (alias != NULL)
	    s = alias;

	if (len <= 0)
	    ret = FAIL;
	else
	{
	    int	    flags = evalarg == NULL ? 0 : evalarg->eval_flags;

	    if (evaluate && in_vim9script() && len == 1 && *s == '_')
	    {
		emsg(_(e_cannot_use_underscore_here));
		ret = FAIL;
	    }
	    else if ((in_vim9script() ? **arg : *skipwhite(*arg)) == '(')
	    {
		// "name(..."  recursive!
		*arg = skipwhite(*arg);
		ret = eval_func(arg, evalarg, s, len, rettv, flags, NULL);
	    }
	    else if (flags & EVAL_CONSTANT)
		ret = FAIL;
	    else if (evaluate)
	    {
		// get the value of "true", "false" or a variable
		if (len == 4 && in_vim9script() && STRNCMP(s, "true", 4) == 0)
		{
		    rettv->v_type = VAR_BOOL;
		    rettv->vval.v_number = VVAL_TRUE;
		    ret = OK;
		}
		else if (len == 5 && in_vim9script()
						&& STRNCMP(s, "false", 5) == 0)
		{
		    rettv->v_type = VAR_BOOL;
		    rettv->vval.v_number = VVAL_FALSE;
		    ret = OK;
		}
		else if (len == 4 && in_vim9script()
						&& STRNCMP(s, "null", 4) == 0)
		{
		    rettv->v_type = VAR_SPECIAL;
		    rettv->vval.v_number = VVAL_NULL;
		    ret = OK;
		}
		else
		{
		    name_start = s;
		    ret = eval_variable(s, len, 0, rettv, NULL,
					   EVAL_VAR_VERBOSE + EVAL_VAR_IMPORT);
		}
	    }
	    else
	    {
		// skip the name
		check_vars(s, len);
		ret = OK;
	    }
	}
	vim_free(alias);
    }

    // Handle following '[', '(' and '.' for expr[expr], expr.name,
    // expr(expr), expr->name(expr)
    if (ret == OK)
	ret = handle_subscript(arg, name_start, rettv, evalarg, TRUE);

    /*
     * Apply logical NOT and unary '-', from right to left, ignore '+'.
     */
    if (ret == OK && evaluate && end_leader > start_leader)
	ret = eval7_leader(rettv, FALSE, start_leader, &end_leader);
    return ret;
}

================================================================================
Suche nach Funktion in primevul_test.jsonl...

Gefunden: 1 EintrÃ¤ge mit dieser Funktion

--- Eintrag 1 ---
{
  "idx": 204243,
  "project": "vim",
  "commit_id": "fe6fb267e6ee5c5da2f41889e4e0e0ac5bf4b89d",
  "project_url": "https://github.com/vim/vim",
  "commit_url": "https://github.com/vim/vim/commit/fe6fb267e6ee5c5da2f41889e4e0e0ac5bf4b89d",
  "commit_message": "patch 8.2.4206: condition with many \"(\" causes a crash\n\nProblem:    Condition with many \"(\" causes a crash.\nSolution:   Limit recursion to 1000.",
  "target": 1,
  "func": "eval7(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\twant_string)\t// after \".\" operator\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    int\t\tlen;\n    char_u\t*s;\n    char_u\t*name_start = NULL;\n    char_u\t*start_leader, *end_leader;\n    int\t\tret = OK;\n    char_u\t*alias;\n\n    /*\n     * Initialise variable so that clear_tv() can't mistake this for a\n     * string and free a string that isn't there.\n     */\n    rettv->v_type = VAR_UNKNOWN;\n\n    /*\n     * Skip '!', '-' and '+' characters.  They are handled later.\n     */\n    start_leader = *arg;\n    if (eval_leader(arg, in_vim9script()) == FAIL)\n\treturn FAIL;\n    end_leader = *arg;\n\n    if (**arg == '.' && (!isdigit(*(*arg + 1))\n#ifdef FEAT_FLOAT\n\t    || in_old_script(2)\n#endif\n\t    ))\n    {\n\tsemsg(_(e_invalid_expression_str), *arg);\n\t++*arg;\n\treturn FAIL;\n    }\n\n    switch (**arg)\n    {\n    /*\n     * Number constant.\n     */\n    case '0':\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case '.':\tret = eval_number(arg, rettv, evaluate, want_string);\n\n\t\t// Apply prefixed \"-\" and \"+\" now.  Matters especially when\n\t\t// \"->\" follows.\n\t\tif (ret == OK && evaluate && end_leader > start_leader\n\t\t\t\t\t\t  && rettv->v_type != VAR_BLOB)\n\t\t    ret = eval7_leader(rettv, TRUE, start_leader, &end_leader);\n\t\tbreak;\n\n    /*\n     * String constant: \"string\".\n     */\n    case '\"':\tret = eval_string(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Literal string constant: 'str''ing'.\n     */\n    case '\\'':\tret = eval_lit_string(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * List: [expr, expr]\n     */\n    case '[':\tret = eval_list(arg, rettv, evalarg, TRUE);\n\t\tbreak;\n\n    /*\n     * Dictionary: #{key: val, key: val}\n     */\n    case '#':\tif (in_vim9script())\n\t\t{\n\t\t    ret = vim9_bad_comment(*arg) ? FAIL : NOTDONE;\n\t\t}\n\t\telse if ((*arg)[1] == '{')\n\t\t{\n\t\t    ++*arg;\n\t\t    ret = eval_dict(arg, rettv, evalarg, TRUE);\n\t\t}\n\t\telse\n\t\t    ret = NOTDONE;\n\t\tbreak;\n\n    /*\n     * Lambda: {arg, arg -> expr}\n     * Dictionary: {'key': val, 'key': val}\n     */\n    case '{':\tif (in_vim9script())\n\t\t    ret = NOTDONE;\n\t\telse\n\t\t    ret = get_lambda_tv(arg, rettv, in_vim9script(), evalarg);\n\t\tif (ret == NOTDONE)\n\t\t    ret = eval_dict(arg, rettv, evalarg, FALSE);\n\t\tbreak;\n\n    /*\n     * Option value: &name\n     */\n    case '&':\tret = eval_option(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Environment variable: $VAR.\n     */\n    case '$':\tret = eval_env_var(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Register contents: @r.\n     */\n    case '@':\t++*arg;\n\t\tif (evaluate)\n\t\t{\n\t\t    if (in_vim9script() && IS_WHITE_OR_NUL(**arg))\n\t\t\tsemsg(_(e_syntax_error_at_str), *arg);\n\t\t    else if (in_vim9script() && !valid_yank_reg(**arg, FALSE))\n\t\t\temsg_invreg(**arg);\n\t\t    else\n\t\t    {\n\t\t\trettv->v_type = VAR_STRING;\n\t\t\trettv->vval.v_string = get_reg_contents(**arg,\n\t\t\t\t\t\t\t\tGREG_EXPR_SRC);\n\t\t    }\n\t\t}\n\t\tif (**arg != NUL)\n\t\t    ++*arg;\n\t\tbreak;\n\n    /*\n     * nested expression: (expression).\n     * or lambda: (arg) => expr\n     */\n    case '(':\tret = NOTDONE;\n\t\tif (in_vim9script())\n\t\t{\n\t\t    ret = get_lambda_tv(arg, rettv, TRUE, evalarg);\n\t\t    if (ret == OK && evaluate)\n\t\t    {\n\t\t\tufunc_T *ufunc = rettv->vval.v_partial->pt_func;\n\n\t\t\t// Compile it here to get the return type.  The return\n\t\t\t// type is optional, when it's missing use t_unknown.\n\t\t\t// This is recognized in compile_return().\n\t\t\tif (ufunc->uf_ret_type->tt_type == VAR_VOID)\n\t\t\t    ufunc->uf_ret_type = &t_unknown;\n\t\t\tif (compile_def_function(ufunc,\n\t\t\t\t     FALSE, COMPILE_TYPE(ufunc), NULL) == FAIL)\n\t\t\t{\n\t\t\t    clear_tv(rettv);\n\t\t\t    ret = FAIL;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (ret == NOTDONE)\n\t\t{\n\t\t    *arg = skipwhite_and_linebreak(*arg + 1, evalarg);\n\t\t    ret = eval1(arg, rettv, evalarg);\t// recursive!\n\n\t\t    *arg = skipwhite_and_linebreak(*arg, evalarg);\n\t\t    if (**arg == ')')\n\t\t\t++*arg;\n\t\t    else if (ret == OK)\n\t\t    {\n\t\t\temsg(_(e_missing_closing_paren));\n\t\t\tclear_tv(rettv);\n\t\t\tret = FAIL;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n    default:\tret = NOTDONE;\n\t\tbreak;\n    }\n\n    if (ret == NOTDONE)\n    {\n\t/*\n\t * Must be a variable or function name.\n\t * Can also be a curly-braces kind of name: {expr}.\n\t */\n\ts = *arg;\n\tlen = get_name_len(arg, &alias, evaluate, TRUE);\n\tif (alias != NULL)\n\t    s = alias;\n\n\tif (len <= 0)\n\t    ret = FAIL;\n\telse\n\t{\n\t    int\t    flags = evalarg == NULL ? 0 : evalarg->eval_flags;\n\n\t    if (evaluate && in_vim9script() && len == 1 && *s == '_')\n\t    {\n\t\temsg(_(e_cannot_use_underscore_here));\n\t\tret = FAIL;\n\t    }\n\t    else if ((in_vim9script() ? **arg : *skipwhite(*arg)) == '(')\n\t    {\n\t\t// \"name(...\"  recursive!\n\t\t*arg = skipwhite(*arg);\n\t\tret = eval_func(arg, evalarg, s, len, rettv, flags, NULL);\n\t    }\n\t    else if (flags & EVAL_CONSTANT)\n\t\tret = FAIL;\n\t    else if (evaluate)\n\t    {\n\t\t// get the value of \"true\", \"false\" or a variable\n\t\tif (len == 4 && in_vim9script() && STRNCMP(s, \"true\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = VVAL_TRUE;\n\t\t    ret = OK;\n\t\t}\n\t\telse if (len == 5 && in_vim9script()\n\t\t\t\t\t\t&& STRNCMP(s, \"false\", 5) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = VVAL_FALSE;\n\t\t    ret = OK;\n\t\t}\n\t\telse if (len == 4 && in_vim9script()\n\t\t\t\t\t\t&& STRNCMP(s, \"null\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_SPECIAL;\n\t\t    rettv->vval.v_number = VVAL_NULL;\n\t\t    ret = OK;\n\t\t}\n\t\telse\n\t\t{\n\t\t    name_start = s;\n\t\t    ret = eval_variable(s, len, 0, rettv, NULL,\n\t\t\t\t\t   EVAL_VAR_VERBOSE + EVAL_VAR_IMPORT);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// skip the name\n\t\tcheck_vars(s, len);\n\t\tret = OK;\n\t    }\n\t}\n\tvim_free(alias);\n    }\n\n    // Handle following '[', '(' and '.' for expr[expr], expr.name,\n    // expr(expr), expr->name(expr)\n    if (ret == OK)\n\tret = handle_subscript(arg, name_start, rettv, evalarg, TRUE);\n\n    /*\n     * Apply logical NOT and unary '-', from right to left, ignore '+'.\n     */\n    if (ret == OK && evaluate && end_leader > start_leader)\n\tret = eval7_leader(rettv, FALSE, start_leader, &end_leader);\n    return ret;\n}",
  "func_hash": 36727009233023880586835574908835910206,
  "file_name": "eval.c",
  "file_hash": 215532001349875821306945607465028796767,
  "cwe": [
    "CWE-787"
  ],
  "cve": "CVE-2022-0351",
  "cve_desc": "Access of Memory Location Before Start of Buffer in GitHub repository vim/vim prior to 8.2.",
  "nvd_url": "https://nvd.nist.gov/vuln/detail/CVE-2022-0351"
}

