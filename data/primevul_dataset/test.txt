
=== Treffer 1 (CWE-Feld: CWE-787: Out-of-bounds Write) ===
int matrix_rank(float** mat, int rows, int cols) {
    // Allocate memory for the rank matrix
    float** rank_mat = malloc(sizeof(float*) * rows);
    for (int i = 0; i < rows; i++) {
        rank_mat[i] = malloc(sizeof(float) * cols);
    }

    // Compute the rank of the matrix
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            // Get the current element of the matrix
            float element = mat[i][j];

            // Increment the rank of the current element
            rank_mat[i][j] += element;
        }
    }

    // Free allocated memory
    for (int i = 0; i < rows; i++) {
        free(rank_mat[i]);
    }
    free(rank_mat);

    return 0;
}

=== Treffer 2 (CWE-Feld: CWE-787: Out-of-bounds Write) ===
void vector_projection(int *vector, int *proj_vector, int length)
{
    // Check if the vectors are null
    if (vector == NULL || proj_vector == NULL)
    {
        printf("Invalid input\n");
        return;
    }

    // Check if the lengths are valid
    if (length <= 0)
    {
        printf("Invalid length\n");
        return;
    }

    // Allocate memory for the projection vector
    proj_vector = (int *)malloc(length * sizeof(int));

    // Initialize the projection vector to zero
    for (int i = 0; i < length; i++)
    {
        proj_vector[i] = 0;
    }

    // Compute the projection of the original vector onto the second vector
    for (int i = 0; i < length; i++)
    {
        // Compute the dot product of the original vector and the second vector
        int dot = 0;
        for (int j = 0; j < length; j++)
        {
            dot += vector[j] * proj_vector[j];
        }

        // Compute the projection of the original vector onto the second vector
        proj_vector[i] = (dot * vector[i]) / length;
    }

    // Free the memory for the projection vector
    free(proj_vector);
}

=== Treffer 3 (CWE-Feld: CWE-787: Out-of-bounds Write) ===
void perform_fourier_transform(float *input, int size) {
    float *output = malloc(size * sizeof(float));
    int i;
    for (i = 0; i < size; i++) {
        output[i] = input[i] + i * 2 * M_PI;
    }
    free(output);
}

=== Treffer 4 (CWE-Feld: CWE-787: Out-of-bounds Write) ===
char* hexadecimal_conversion(const char* input) {
    char* output = malloc(strlen(input) * 2 + 1);
    for (int i = 0; i < strlen(input); i++) {
        int value = input[i];
        output[i * 2] = (value % 16) + '0';
        output[i * 2 + 1] = (value / 16) + '0';
    }
    return output;
}

=== Treffer 5 (CWE-Feld: CWE-787: Out-of-bounds Write) ===
int digital_filter_design(int argc, char **argv)
{
    // Set up input file
    FILE *input_file;
    if (argc < 2)
    {
        printf("Usage: %s <input_file>\n", argv[0]);
        return 1;
    }
    if ((input_file = fopen(argv[1], "r")) == NULL)
    {
        printf("Failed to open input file.");
        return 1;
    }

    // Read input file
    int num_samples;
    int sample_rate;
    int channels;
    if (fscanf(input_file, "%d %d %d", &num_samples, &sample_rate, &channels) != 3)
    {
        printf("Error reading input file.");
        return 1;
    }
    // Allocate memory for samples
    float *samples = (float *)malloc(num_samples * channels * sizeof(float));
    if (samples == NULL)
    {
        printf("Failed to allocate memory for samples.");
        return 1;
    }
    // Read samples
    if (fread(samples, sizeof(float), num_samples * channels, input_file) != num_samples * channels)
    {
        printf("Error reading samples.");
        free(samples);
        return 1;
    }
    // Close input file
    fclose(input_file);

    // Filter the samples
    float low_cutoff = 20;
    float high_cutoff = 100;
    int filter_len = 20;
    float *filter = (float *)malloc(filter_len * sizeof(float));
    if (filter == NULL)
    {
        printf("Failed to allocate memory for filter.");
        free(samples);
        return 1;
    }
    for (int i = 0; i < filter_len; i++)
    {
        filter[i] = 0.5 * (1 - cos(2 * M_PI * i / (filter_len - 1)));
    }
    for (int i = 0; i < num_samples; i++)
    {
        for (int j = 0; j < channels; j++)
        {
            float sample = samples[i * channels + j];
            for (int k = 0; k < filter_len; k++)
            {
                sample += filter[k] * samples[(i + k) * channels + j];
            }
            samples[i * channels + j] = sample;
        }
    }
    free(filter);

    // Write output file
    FILE *output_file;
    if ((output_file = fopen("output.txt", "w")) == NULL)
    {
        printf("Failed to open output file.");
        free(samples);
        return 1;
    }
    for (int i = 0; i < num_samples; i++)
    {
        for (int j = 0; j < channels; j++)
        {
            fprintf(output_file, "%.4f\n", samples[i * channels + j]);
        }
    }
    fclose(output_file);

    free(samples);
    return 0;
}

=== Treffer 6 (CWE-Feld: CWE-787: Out-of-bounds Write) ===
void matrix_diagonalization(int **A, int n) {
  int i, j;
  int *diagonal = malloc(n * sizeof(int));
  for (i = 0; i < n; i++) {
    diagonal[i] = 0;
  }
  for (i = 0; i < n; i++) {
    for (j = 0; j < A[i]->n; j++) {
      if (A[i][j] != 0) {
        diagonal[j]++;
      }
    }
  }
  for (i = 0; i < n; i++) {
    if (diagonal[i] != 0) {
      diagonalf[i] = diagonal[i] / 2;
    }
  }
  free(diagonal);
}

=== Treffer 7 (CWE-Feld: CWE-787: Out-of-bounds Write) ===
void matrix_adjugate(int* matrix, int m, int n)
{
    int i, j, prod;

    // Allocate memory for the adjugate matrix
    int* adjugate = (int*)malloc(m * n * sizeof(int));

    // Compute the adjugate matrix
    for (i = 0; i < m; i++)
    {
        for (j = 0; j < n; j++)
        {
            prod = 1;
            for (int k = 0; k < n; k++)
            {
                if (k != j && i != k)
                {
                    prod *= matrix[i * n + k];
                }
            }
            adjugate[i * n + j] = prod;
        }
    }

    // Clean up
    free(adjugate);
}

=== Treffer 8 (CWE-Feld: CWE-787: Out-of-bounds Write) ===
void matrix_inverse(double *matrix, int rows, int cols) {
  int i, j;
  double *inv_matrix = malloc(rows * cols * sizeof(double));

  for (i = 0; i < rows; i++) {
    for (j = 0; j < cols; j++) {
      if (matrix[i * cols + j] == 0) {
        inv_matrix[i * cols + j] = 0;
      } else {
        inv_matrix[i * cols + j] = 1 / matrix[i * cols + j];
      }
    }
  }

  for (i = 0; i < rows; i++) {
    for (j = 0; j < cols; j++) {
      printf("%f ", inv_matrix[i * cols + j]);
    }
    printf("\n");
  }

  free(inv_matrix);
}

=== Treffer 9 (CWE-Feld: CWE-787: Out-of-bounds Write) ===
float* singular_value_decomposition(int size, int num_iterations, float* input) {
  // this function performs a singular value decomposition of a matrix
  float* output = (float*)malloc(size * sizeof(float));
  float* u = (float*)malloc(size * sizeof(float));
  float* v = (float*)malloc(num_iterations * sizeof(float));
  float w[size];
  float k[num_iterations];
  int i, j;
  
  // calculate the singular values and vectors
  for (i = 0; i < num_iterations; i++) {
    for (j = 0; j < size; j++) {
      output[j + i * size] = input[j] * u[i];
      u[i] /= sqrt(output[j + i * size] * output[j + i * size]);
    }
    
    // normalize the vector
    for (j = 0; j < size; j++) {
      normalize(output[j + i * size], u[i], v[j]);
    }
  }
  
  // create the singular values and vectors
  for (i = 0; i < num_iterations; i++) {
    for (j = 0; j < size; j++) {
      w[j + i * size] = output[i * size] * v[j];
      k[i] /= sqrt(w[j + i * size] * w[j + i * size]);
    }
  }
  
  free(u);
  free(v);
  return output;
}

=== Treffer 10 (CWE-Feld: CWE-787: Out-of-bounds Write) ===
void numerically_solve_pde(int width, int height, double* data, int* boundary_conditions) {
    double* out = malloc(width * height * sizeof(double));
    int i, j;

    for (i = 0; i < height; i++) {
        for (j = 0; j < width; j++) {
            double value = data[i * width + j] + boundary_conditions[i * width + j];
            if (value > 0) {
                out[i * width + j] = value;
            } else {
                out[i * width + j] = 0;
            }
        }
    }

    free(out);
}
